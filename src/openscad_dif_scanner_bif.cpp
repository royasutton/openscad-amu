/***************************************************************************//**

  \file   openscad_dif_scanner_bif.cpp

  \author Roy Allen Sutton
  \date   2016-2018

  \copyright

    This file is part of OpenSCAD AutoMake Utilities ([openscad-amu]
    (https://royasutton.github.io/openscad-amu)).

    openscad-amu is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    openscad-amu is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    [GNU General Public License] (https://www.gnu.org/licenses/gpl.html)
    for more details.

    You should have received a copy of the GNU General Public License
    along with openscad-amu.  If not, see <http://www.gnu.org/licenses/>.

  \brief
    OpenSCAD Doxygen input filter scanner class built-in functions source.

  \ingroup openscad_dif_src
*******************************************************************************/

#include "openscad_dif_scanner.hpp"

#include <boost/filesystem.hpp>
#include <boost/tokenizer.hpp>
#include <boost/algorithm/string.hpp>
#include <boost/regex.hpp>
#include <boost/xpressive/xpressive.hpp>

#include <set>

#if defined(HAVE_CONFIG_H)
#include "config.h"
#endif

using namespace std;
namespace bfs = boost::filesystem;


/***************************************************************************//**

  \details

    Create a local copy of the global variable scope and process each
    argument one-by-one.

    \em Named argument value pairs are stored to the local variable
    scope by default. A \em flag arguments will store a value of 1 or
    -1 (ie: ++i will store i=1). The special flags \p ++/--global and
    \p ++/--local control if the respective variable scope will be
    updated for subsequent assignments.

    Flag               | Default  | Description
    :------------------|:--------:|:------------------------------
    ++local, --local   | true     | update local variable scope
    ++global, --global | false    | update global variable scope

    \em Positional arguments are expanded and appended to the return
    value. Each argument is separated by a configurable feild
    separator, ${EFS}. By default, ${EFS}='[:space:]'. Escaped
    variables are reduced and checked during subsequent expansions.
    Delayed expansion is required to access the value of a variable
    stored using the \em flag syntax.

    The result is returned when there are no more named or positional
    arguments.

    For more information on how to specify and use function arguments
    see \ref openscad_dif_sm_a.

*******************************************************************************/
string
ODIF::ODIF_Scanner::bif_eval(void)
{
  bool update_local = true;
  bool update_global = false;

  // create local copy of the global variable scope map
  env_var vm = varm;

  // setup feild separator variable vm reference
  string efs = vm.get_prefix() + "EFS" + vm.get_suffix();

  string result;

  // iterate over the arguments, skipping function name (position zero)
  for ( vector<func_args::arg_term>::iterator it=fx_argv.argv.begin()+1;
                                              it!=fx_argv.argv.end();
                                              ++it )
  {
    // argument is positional
    if ( it->positional )
    {
      // append feild separator
      if ( result.length() != 0 )
        result.append( UTIL::unquote( vm.expand(efs) ) );

      // expand and append positional argument text
      result.append( vm.expand_text( it->value ) );
    }
    // argument is named or flag
    else
    {
      // test for flags 'global' or 'local'
      if ( it->name.compare("global") == 0  )
        update_global = ( atoi( it->value.c_str() ) > 0 );
      else if ( it->name.compare("local") == 0  )
        update_local = ( atoi( it->value.c_str() ) > 0 );
      else
      // add name=value pair to variable map
      {
        // local
        if ( update_local ) vm.store( it->name, it->value );

        // global
        if ( update_global ) varm.store( it->name, it->value );
      }
    }
  }

  return( result );
}

/***************************************************************************//**

  \details

    Execute the string at the first positional argument in a shell. The
    output generated by the command is captured to a string, striped of
    all return and linefeed characters and returned.

    The flags and their short codes are summarized in the following
    table.

     flags   | sc  | default | description
    :-------:|:---:|:-------:|:-----------------------------------------
      stderr | s   | false   | capture standard error output as well
      rmnl   | r   | true    | remove line-feeds / carriage returns
      eval   | e   | false   | expand variables in text

    For more information on how to specify and use function arguments
    see \ref openscad_dif_sm_a.

*******************************************************************************/
string
ODIF::ODIF_Scanner::bif_shell(void)
{
  // options declaration: vana & vans.
  // !!DO NOT REORDER WITHOUT UPDATING POSITIONAL DEPENDENCIES BELOW!!
  string vana[] =
  {
  "stderr",   "s",
  "rmnl",     "r",
  "eval",     "e"
  };
  set<string> vans(vana, vana + sizeof(vana)/sizeof(string));

  // declare and assign flag defaults
  size_t ap=0;
  bool flag_stde = false; ap+=2;
  bool flag_rmnl = true;  ap+=2;
  bool flag_eval = false; ap+=2;

  // generate options help string.
  string help = "flags: [";
  for(size_t it=0; it < ap; it+=2) {
    if (it) help.append( ", " );
    help.append( vana[it] + " (" + vana[it+1] + ")" );
  }
  help.append( "]" );

  // assign local variable flags:
  vector<string> av = fx_argv.names_v(true, false);
  for ( vector<string>::iterator it=av.begin(); it!=av.end(); ++it )
  {
    bool found;

    if      (!(it->compare(vana[0])&&it->compare(vana[1])))
      flag_stde=( atoi(fx_argv.arg(*it, found).c_str()) > 0 );
    else if (!(it->compare(vana[2])&&it->compare(vana[3])))
      flag_rmnl=( atoi(fx_argv.arg(*it, found).c_str()) > 0 );
    else if (!(it->compare(vana[4])&&it->compare(vana[5])))
      flag_eval=( atoi(fx_argv.arg(*it, found).c_str()) > 0 );
    else
      return( amu_error_msg(*it + " invalid flag. " + help) );
  }

  //
  // general argument validation:
  //

  // enforce one positional argument (except arg0).
  if ( fx_argv.size(false, true) != 2 )
    return(amu_error_msg("requires a single positional argument. " + help));

  // unquote and trim the command string
  string scmd = UTIL::unquote_trim( fx_argv.arg( 1 ) );

  string result;
  bool good=false;

  filter_debug( scmd );
  UTIL::sys_command( scmd, result, good, flag_stde, flag_rmnl );

  if ( good == false )
  {
    return( amu_error_msg( result) );
  }
  else
  {
    if (flag_eval)
      result = varm.expand_text(result);

    return( result );
  }
}

/***************************************************************************//**

  \details

    For a list of sets: <tt>set1, set2, ..., setn,</tt> combine each
    element of each set one at a time to form a named n-tuple word
    connected by a configurable joiner string. Each word has a
    configurable prefix added to its front and configurable suffix
    added to its end and are appended to the return value with a
    configurable word separator.

    Each positional argument is a separate set. Sets with multiple
    members require its members to be enclosed within quotation marks.
    The tokenizer character are used to separate the lists of set
    members.

    The options and their short codes are summarized in the following
    table.

     options     | sc  | default        | description
    :-----------:|:---:|:--------------:|:--------------------------------
      prefix     | p   |                | word prefix
      suffix     | s   |                | word suffix
      joiner     | j   | [_]            | set member joiner
      separator  | f   | [,]            | word separator
      tokenizer  | t   | [\|,[:space:]] | set-members tokenizer characters

    For more information on how to specify and use function arguments
    see \ref openscad_dif_sm_a.

*******************************************************************************/
string
ODIF::ODIF_Scanner::bif_combine(void)
{
  using namespace UTIL;

  // options declaration: vana & vans.
  // !!DO NOT REORDER WITHOUT UPDATING POSITIONAL DEPENDENCIES BELOW!!
  string vana[] =
  {
  "prefix",     "p",
  "suffix",     "s",
  "joiner",     "j",
  "separator",  "f",
  "tokenizer",  "t"
  };
  set<string> vans(vana, vana + sizeof(vana)/sizeof(string));

  // assign local variable values: positions must match declaration above.
  // do not trim to allow combining of natural language.
  size_t ap=0;
  string prefix     = unquote(fx_argv.arg_firstof(   "",vana[ap],vana[ap+1])); ap+=2;
  string suffix     = unquote(fx_argv.arg_firstof(   "",vana[ap],vana[ap+1])); ap+=2;
  string joiner     = unquote(fx_argv.arg_firstof(  "_",vana[ap],vana[ap+1])); ap+=2;
  string separator  = unquote(fx_argv.arg_firstof(  ",",vana[ap],vana[ap+1])); ap+=2;
  string tokenizer  = unquote(fx_argv.arg_firstof("|, ",vana[ap],vana[ap+1])); ap+=2;

  // generate options help string.
  string help = "options: [";
  for(size_t it=0; it < ap; it+=2) {
    if (it) help.append( ", " );
    help.append( vana[it] + " (" + vana[it+1] + ")" );
  }
  help.append( "]" );

  // validate named arguments: (must be one of the declared options).
  vector<string> av = fx_argv.names_v(true, false);
  for ( vector<string>::iterator it=av.begin(); it!=av.end(); ++it )
    if ( vans.find( *it ) == vans.end() )
      return( amu_error_msg(*it + " invalid option. " + help) );

  //
  // general argument validation:
  //

  // get the positional arguments as vector (except arg0).
  vector<string> pa = fx_argv.values_v(false, true);
  pa.erase( pa.begin() );

  // created the vector of sets to combine with grouping quotes removed.
  // do not trim to allow combining of natural language.
  vector<string> sv;
  for ( vector<string>::iterator it=pa.begin(); it!=pa.end(); ++it )
    sv.push_back( unquote( *it ) );

  string result;
  bif_combineR( result, sv, prefix, suffix, joiner, separator, tokenizer);

  return( result );
}

void
ODIF::ODIF_Scanner::bif_combineR( string &r, vector<string> sv,
                                  const string &p, const string &s,
                                  const string &j, const string &ws,
                                  const string &t )
{
  // check recursion termination.
  if ( sv.size()== 0 )
  {
    // append word separator after the first word
    if( r.length() !=0 ) r+= ws;

    r+=p + s;
  }
  else
  {
    // separate member words of first set of 'sv' and store in 'sm'
    string          fs = sv.front();
    vector<string>  sm;

    typedef boost::tokenizer< boost::char_separator<char> > tokenizer;

    boost::char_separator<char> sep( t.c_str() );
    tokenizer tokens(fs, sep);

    for ( tokenizer::iterator it=tokens.begin(); it!=tokens.end(); ++it )
      sm.push_back( j + *it );

    // for each word in 'sm' combine with words of remaining sets
    sv.erase( sv.begin() );
    for ( vector<string>::iterator it=sm.begin(); it!=sm.end(); ++it )
      bif_combineR(r, sv, p + *it, s, j, ws, t);
  }
}

/***************************************************************************//**
  \details


    Output a table formated from a list of text phrases. The options
    and their short codes are summarized in the following table.

     options            | sc  | default  | tokenizer | description
    :------------------:|:---:|:--------:|:---------:|:----------------------------
      id                | i   |          |           |  table id
      table_caption     | t   |          |           |  table caption
      columns           | c   |    6     |           |  number of columns
      table_class       | sc  | doxtable |           |  table css class
      column_headings   | chl |          |  titles   |  column headings list
      cell_texts        | cdl |          |  titles   |  cell text list
      cell_captions     | ccl |          |  titles   |  cell caption list
      cell_urls         | cul |          |  urls     |  cell URL list

    The tokenizer character that separates list members are summarized in the
    following table.

     type   | any of
    :------:|:---------------:
     titles | [~^]
     urls   | [^\|#[:space:]]

    For more information on how to specify and use function arguments
    see \ref openscad_dif_sm_a.

*******************************************************************************/
string
ODIF::ODIF_Scanner::bif_table(void)
{
  using namespace UTIL;

  // options declaration: vana & vans.
  // !!DO NOT REORDER WITHOUT UPDATING POSITIONAL DEPENDENCIES BELOW!!
  string vana[] =
  {
  "id",               "i",
  "table_caption",    "t",
  "columns",          "c",
  "table_class",      "sc",
  "column_headings",  "chl",
  "cell_texts",       "cdl",
  "cell_captions",    "ccl",
  "cell_urls",        "cul"
  };
  set<string> vans(vana, vana + sizeof(vana)/sizeof(string));

  // assign local variable values: positions must match declaration above.
  size_t ap=0;
  string id               = unquote_trim(fx_argv.arg_firstof("",vana[ap],vana[ap+1])); ap+=2;
  string table_caption    = unquote_trim(fx_argv.arg_firstof("",vana[ap],vana[ap+1])); ap+=2;
  string columns          = unquote_trim(fx_argv.arg_firstof("",vana[ap],vana[ap+1])); ap+=2;
  string table_class      = unquote_trim(fx_argv.arg_firstof("",vana[ap],vana[ap+1])); ap+=2;
  string column_headings  = unquote_trim(fx_argv.arg_firstof("",vana[ap],vana[ap+1])); ap+=2;
  string cell_texts       = unquote_trim(fx_argv.arg_firstof("",vana[ap],vana[ap+1])); ap+=2;
  string cell_captions    = unquote_trim(fx_argv.arg_firstof("",vana[ap],vana[ap+1])); ap+=2;
  string cell_urls        = unquote_trim(fx_argv.arg_firstof("",vana[ap],vana[ap+1])); ap+=2;

  // generate options help string.
  string help = "options: [";
  for(size_t it=0; it < ap; it+=2) {
    if (it) help.append( ", " );
    help.append( vana[it] + " (" + vana[it+1] + ")" );
  }
  help.append( "]" );

  // validate named arguments: (must be one of the declared options).
  vector<string> av = fx_argv.names_v(true, false);
  for ( vector<string>::iterator it=av.begin(); it!=av.end(); ++it )
    if ( vans.find( *it ) == vans.end() )
      return( amu_error_msg(*it + " invalid option. " + help) );

  //
  // general argument validation:
  //

  // enforce zero positional arguments (except arg0).
  if ( fx_argv.size(false, true) != 1 )
    return(amu_error_msg("requires zero positional argument. " + help));

  // apply default: columns.
  size_t columns_cnt = 6;
  if ( columns.length() ) {
    if ( is_number( columns ) )
      columns_cnt = atoi( columns.c_str() );
    else
      return( amu_error_msg(vana[4] + "=[" + columns + "] is invalid.") );
  }

  // apply default: table_class
  if ( table_class.empty() ) table_class = "doxtable";

  //
  // tokenize arguments with list members to vectors
  //
  typedef boost::tokenizer< boost::char_separator<char> > tokenizer;

  boost::char_separator<char> tsep("~^");   // general text separators
  boost::char_separator<char> usep("^|# "); // url text separators

  // column_headings
  tokenizer chl_tok( column_headings, tsep );
  vector<string> chl_v;
  for ( tokenizer::iterator it=chl_tok.begin(); it!=chl_tok.end(); ++it )
    chl_v.push_back( boost::trim_copy( *it ) );

  // cell_texts
  tokenizer cdl_tok( cell_texts, tsep );
  vector<string> cdl_v;
  for ( tokenizer::iterator it=cdl_tok.begin(); it!=cdl_tok.end(); ++it )
    cdl_v.push_back( boost::trim_copy( *it ) );

  // cell_captions
  tokenizer ccl_tok( cell_captions, tsep );
  vector<string> ccl_v;
  for ( tokenizer::iterator it=ccl_tok.begin(); it!=ccl_tok.end(); ++it )
    ccl_v.push_back( boost::trim_copy( *it ) );

  // cell_urls
  tokenizer cul_tok( cell_urls, usep );
  vector<string> cul_v;
  for ( tokenizer::iterator it=cul_tok.begin(); it!=cul_tok.end(); ++it )
    cul_v.push_back( boost::trim_copy( *it ) );

  // must be a heading for every column (vana[ column_headings ])
  if ( (chl_v.size() >0) && (chl_v.size() != columns_cnt) )
    return( amu_error_msg("mismatched " + vana[8] + ": " + to_string(chl_v.size()) +
                          " headings for " + to_string(columns_cnt) + " columns.") );

  // must be a caption for every cell (vana[ cell_captions ])
  if ( (ccl_v.size() >0) && (ccl_v.size() != cdl_v.size()) )
    return( amu_error_msg("mismatched " + vana[12] + ": " + to_string(ccl_v.size()) +
                          " captions for " + to_string(cdl_v.size()) + " cells.") );

  // must be a url for every cell (vana[ cell_urls ])
  if ( (cul_v.size() >0) && (cul_v.size() != cdl_v.size()) )
    return( amu_error_msg("mismatched " + vana[14] + ": " + to_string(cul_v.size()) +
                          " URLs for " + to_string(cdl_v.size()) + " cells.") );


  // embedded newline output control for debugging.
  // when set to true, while useful for visually debugging the output
  // of this filter, may cause Doxygen to produce erroneous results.
  #define IDINL if(_NLE_) result.append("\n")
  bool _NLE_ = false;

  string result;

  // ----------------------------------------------------------------- //
  //                            html table
  // ----------------------------------------------------------------- //

  // begin table
  IDINL;
  result.append("<table class=\"" + table_class + "\">");
  IDINL;

  // table_caption and optional id
  if( table_caption.length() ) {
    result.append("<caption");
    if ( id.length() ) result.append(" id=\"" + id + "\"");
    result.append(">" + table_caption + "</caption>");
    IDINL;
  }

  // column_headings
  if( column_headings.length() ) {
    result.append("<tr>");
    for( size_t i=0; i<columns_cnt; ++i )
      result.append("<th>" + chl_v[i] + "</th>");
    result.append("</tr>");
    IDINL;
  }

  // iterate over cells
  int cdl_num = 0;
  for ( vector<string>::const_iterator it=cdl_v.begin(); it!=cdl_v.end(); ++it )
  {
    const string text = *it;

    // check new row
    if ( (cdl_num%columns_cnt) == 0 ) {
      // cell captions
      if( cell_captions.length() ) {
        result.append("<tr>");
        for( size_t i=0; i<columns_cnt; ++i )
          if( (cdl_num + i) < cdl_v.size() )
            result.append("<th>" + ccl_v[cdl_num + i] + "</th>");
        result.append("</tr>");
        IDINL;
      }

      // begin row
      result.append("<tr>");
      IDINL;
    }

    // begin cell text
    result.append("<td>");

    bool found = false;
    if ( cell_urls.length() ) result.append( "<a href=\""
        + file_rl( cul_v[cdl_num], get_html_output(), found )
        + "\">" );

    result.append( text );

    if ( cell_urls.length() ) result.append("</a>");

    // end cell
    result.append("</td>");
    IDINL;

    // end row
    if ( (cdl_num%columns_cnt) == (columns_cnt-1) ) {
      result.append("</tr>");
      IDINL;
    }

    cdl_num++;
  }

  // end table
  result.append("</table>");

  return( result );
}

/***************************************************************************//**
  \details

    Output a table of images in \c html or \c latex format. The options
    and their short codes are summarized in the following table.

     options            | sc  | default  | tokenizer | description
    :------------------:|:---:|:--------:|:---------:|:----------------------------
      type              | f   |          |           |  table type (html or latex)
      id                | i   |          |           |  table id
      table_caption     | t   |          |           |  table caption
      columns           | c   |    3     |           |  number of columns
      table_class       | sc  | doxtable |           |  table css class
      image_width       | iw  |          |           |  width for each image
      image_height      | ih  |          |           |  height for each image
      column_headings   | chl |          |  titles   |  column headings list
      cell_begin        | cdb |          |  titles   |  initial text for each cell
      cell_end          | cde |          |  titles   |  final text for each cell
      cell_files        | cdl |          |  files    |  cell image list
      cell_titles       | ctl |          |  titles   |  cell title list
      cell_captions     | ccl |          |  titles   |  cell caption list
      cell_urls         | cul |          |  urls     |  cell URL list

    The tokenizer character that separates list members are summarized in the
    following table.

     type   | any of
    :------:|:---------------:
     files  | [,[:space:]]
     titles | [~^]
     urls   | [^\|#[:space:]]

    When using \p cell_urls, the function may need to be enclosed by \p
    \\htmlonly and \p \\endhtmlonly to prevent Doxygen from rewriting
    the assigned urls as show below.

    \verbatim
      // image table with cell urls

      \htmlonly
        \amu_image_table (
            type=html table_caption="Downloadable"
            cell_files="${png_files}" cell_captions="${titles}"
            cell_urls="${stl_files}"
        )
      \endhtmlonly
    \endverbatim

    For more information on how to specify and use function arguments
    see \ref openscad_dif_sm_a.

*******************************************************************************/
string
ODIF::ODIF_Scanner::bif_image_table(void)
{
  using namespace UTIL;

  // options declaration: vana & vans.
  // !!DO NOT REORDER WITHOUT UPDATING POSITIONAL DEPENDENCIES BELOW!!
  string vana[] =
  {
  "type",             "f",
  "id",               "i",
  "table_caption",    "t",
  "columns",          "c",
  "table_class",      "sc",
  "image_width",      "iw",
  "image_height",     "ih",
  "column_headings",  "chl",
  "cell_begin",       "cdb",
  "cell_end",         "cde",
  "cell_files",       "cdl",
  "cell_titles",      "ctl",
  "cell_captions",    "ccl",
  "cell_urls",        "cul"
  };
  set<string> vans(vana, vana + sizeof(vana)/sizeof(string));

  // assign local variable values: positions must match declaration above.
  size_t ap=0;
  string type             = unquote_trim(fx_argv.arg_firstof("",vana[ap],vana[ap+1])); ap+=2;
  string id               = unquote_trim(fx_argv.arg_firstof("",vana[ap],vana[ap+1])); ap+=2;
  string table_caption    = unquote_trim(fx_argv.arg_firstof("",vana[ap],vana[ap+1])); ap+=2;
  string columns          = unquote_trim(fx_argv.arg_firstof("",vana[ap],vana[ap+1])); ap+=2;
  string table_class      = unquote_trim(fx_argv.arg_firstof("",vana[ap],vana[ap+1])); ap+=2;
  string image_width      = unquote_trim(fx_argv.arg_firstof("",vana[ap],vana[ap+1])); ap+=2;
  string image_height     = unquote_trim(fx_argv.arg_firstof("",vana[ap],vana[ap+1])); ap+=2;
  string column_headings  = unquote_trim(fx_argv.arg_firstof("",vana[ap],vana[ap+1])); ap+=2;
  string cell_begin       = unquote_trim(fx_argv.arg_firstof("",vana[ap],vana[ap+1])); ap+=2;
  string cell_end         = unquote_trim(fx_argv.arg_firstof("",vana[ap],vana[ap+1])); ap+=2;
  string cell_files       = unquote_trim(fx_argv.arg_firstof("",vana[ap],vana[ap+1])); ap+=2;
  string cell_titles      = unquote_trim(fx_argv.arg_firstof("",vana[ap],vana[ap+1])); ap+=2;
  string cell_captions    = unquote_trim(fx_argv.arg_firstof("",vana[ap],vana[ap+1])); ap+=2;
  string cell_urls        = unquote_trim(fx_argv.arg_firstof("",vana[ap],vana[ap+1])); ap+=2;

  // generate options help string.
  string help = "options: [";
  for(size_t it=0; it < ap; it+=2) {
    if (it) help.append( ", " );
    help.append( vana[it] + " (" + vana[it+1] + ")" );
  }
  help.append( "]" );

  // validate named arguments: (must be one of the declared options).
  vector<string> av = fx_argv.names_v(true, false);
  for ( vector<string>::iterator it=av.begin(); it!=av.end(); ++it )
    if ( vans.find( *it ) == vans.end() )
      return( amu_error_msg(*it + " invalid option. " + help) );

  //
  // general argument validation:
  //

  // enforce zero positional arguments (except arg0).
  if ( fx_argv.size(false, true) != 1 )
    return(amu_error_msg("requires zero positional argument. " + help));

  // required arguments: type must exists and be one of 'html' or 'latex'
  if ( ! fx_argv.exists( vana[0] ) && ! fx_argv.exists( vana[1] ) )
    return( amu_error_msg("table type must be specified. may be (html|latex).") );
  else if ( type.compare("html") && type.compare("latex") )
    return( amu_error_msg( "type " + type + " is invalid. may be (html|latex).") );

  // apply default: columns.
  size_t columns_cnt = 3;
  if ( columns.length() ) {
    if ( is_number( columns ) )
      columns_cnt = atoi( columns.c_str() );
    else
      return( amu_error_msg(vana[6] + "=[" + columns + "] is invalid.") );
  }

  // apply default: table_class
  if ( table_class.empty() ) table_class = "doxtable";

  //
  // tokenize arguments with list members to vectors
  //
  typedef boost::tokenizer< boost::char_separator<char> > tokenizer;

  boost::char_separator<char> fsep(", ");   // file name separators
  boost::char_separator<char> tsep("~^");   // general text separators
  boost::char_separator<char> usep("^|# "); // url text separators

  // column_headings
  tokenizer chl_tok( column_headings, tsep );
  vector<string> chl_v;
  for ( tokenizer::iterator it=chl_tok.begin(); it!=chl_tok.end(); ++it )
    chl_v.push_back( boost::trim_copy( *it ) );

  // cell_begin
  tokenizer cdb_tok( cell_begin, tsep );
  vector<string> cdb_v;
  for ( tokenizer::iterator it=cdb_tok.begin(); it!=cdb_tok.end(); ++it )
    cdb_v.push_back( boost::trim_copy( *it ) );

  // cell_end
  tokenizer cde_tok( cell_end, tsep );
  vector<string> cde_v;
  for ( tokenizer::iterator it=cde_tok.begin(); it!=cde_tok.end(); ++it )
    cde_v.push_back( boost::trim_copy( *it ) );

  // cell_files
  tokenizer cdl_tok( cell_files, fsep );
  vector<string> cdl_v;
  for ( tokenizer::iterator it=cdl_tok.begin(); it!=cdl_tok.end(); ++it )
    cdl_v.push_back( boost::trim_copy( *it ) );

  // cell_titles
  tokenizer ctl_tok( cell_titles, tsep );
  vector<string> ctl_v;
  for ( tokenizer::iterator it=ctl_tok.begin(); it!=ctl_tok.end(); ++it )
    ctl_v.push_back( boost::trim_copy( *it ) );

  // cell_captions
  tokenizer ccl_tok( cell_captions, tsep );
  vector<string> ccl_v;
  for ( tokenizer::iterator it=ccl_tok.begin(); it!=ccl_tok.end(); ++it )
    ccl_v.push_back( boost::trim_copy( *it ) );

  // cell_urls
  tokenizer cul_tok( cell_urls, usep );
  vector<string> cul_v;
  for ( tokenizer::iterator it=cul_tok.begin(); it!=cul_tok.end(); ++it )
    cul_v.push_back( boost::trim_copy( *it ) );

  // must be a heading for every column (vana[ column_headings ])
  if ( (chl_v.size() >0) && (chl_v.size() != columns_cnt) )
    return( amu_error_msg("mismatched " + vana[14] + ": " + to_string(chl_v.size()) +
                          " headings for " + to_string(columns_cnt) + " columns.") );

  // must be a begin for every cell (vana[ cell_begin ])
  if ( (cdb_v.size() >0) && (cdb_v.size() != cdl_v.size()) )
    return( amu_error_msg("mismatched " + vana[16] + ": " + to_string(cdb_v.size()) +
                          " begins for " + to_string(cdl_v.size()) + " cells.") );

  // must be an end for every cell (vana[ cell_end ])
  if ( (cde_v.size() >0) && (cde_v.size() != cdl_v.size()) )
    return( amu_error_msg("mismatched " + vana[18] + ": " + to_string(cde_v.size()) +
                          " ends for " + to_string(cdl_v.size()) + " cells.") );

  // must be a title for every cell (vana[ cell_titles ])
  if ( (ctl_v.size() >0) && (ctl_v.size() != cdl_v.size()) )
    return( amu_error_msg("mismatched " + vana[22] + ": " + to_string(ctl_v.size()) +
                          " titles for " + to_string(cdl_v.size()) + " cells.") );

  // must be a caption for every cell (vana[ cell_captions ])
  if ( (ccl_v.size() >0) && (ccl_v.size() != cdl_v.size()) )
    return( amu_error_msg("mismatched " + vana[24] + ": " + to_string(ccl_v.size()) +
                          " captions for " + to_string(cdl_v.size()) + " cells.") );

  // must be a url for every cell (vana[ cell_urls ])
  if ( (cul_v.size() >0) && (cul_v.size() != cdl_v.size()) )
    return( amu_error_msg("mismatched " + vana[26] + ": " + to_string(cul_v.size()) +
                          " URLs for " + to_string(cdl_v.size()) + " cells.") );


  // embedded newline output control for debugging.
  // when set to true, while useful for visually debugging the output
  // of this filter, may cause Doxygen to produce erroneous results.
  #define IDINL if(_NLE_) result.append("\n")
  bool _NLE_ = false;

  string result;

  // ----------------------------------------------------------------- //
  //                            html table
  // ----------------------------------------------------------------- //
  if ( type.compare("html")==0 ) {

    // begin table
    IDINL;
    result.append("<table class=\"" + table_class + "\">");
    IDINL;

    // table caption and id
    if( table_caption.length() ) {
      result.append("<caption");
      if ( id.length() ) result.append(" id=\"" + id + "\"");
      result.append(">" + table_caption + "</caption>");
      IDINL;
    }

    // column headings
    if( column_headings.length() ) {
      result.append("<tr>");
      for( size_t i=0; i<columns_cnt; ++i )
        result.append("<th>" + chl_v[i] + "</th>");
      result.append("</tr>");
      IDINL;
    }

    // iterate over cells
    int cdl_num = 0;
    for ( vector<string>::const_iterator it=cdl_v.begin(); it!=cdl_v.end(); ++it )
    {
      const string file = *it;

      // check new row
      if ( (cdl_num%columns_cnt) == 0 ) {
        // image headings
        if( cell_captions.length() ) {
          result.append("<tr>");
          for( size_t i=0; i<columns_cnt; ++i )
            if( (cdl_num + i) < cdl_v.size() )
              result.append("<th>" + ccl_v[cdl_num + i] + "</th>");
          result.append("</tr>");
          IDINL;
        }

        // begin row
        result.append("<tr>");
        IDINL;
      }

      // begin cell
      result.append("<td>");

      // first text for each cell
      if ( cell_begin.length() ) result.append( cdb_v[cdl_num] );

      // begin cell image
      bool found = false;
      if ( cell_urls.length() ) result.append( "<a href=\""
          + file_rl( cul_v[cdl_num], get_html_output(), found )
          + "\">" );

      result.append( "<img src=\"" + file_rl( file, get_html_output(), found ) + "\"" );

      if ( cell_titles.length() ) {
        result.append(" title=\"" + ctl_v[cdl_num] + "\"");
        result.append(" alt=\"" + ctl_v[cdl_num] + "\"");
      }

      if ( image_width.length() ) result.append(" width=\"" + image_width + "\"");
      if ( image_height.length() ) result.append(" height=\"" + image_height + "\"");

      // end cell image
      result.append(">");
      if ( cell_urls.length() ) result.append("</a>");

      // last text for each cell
      if ( cell_end.length() ) result.append( cde_v[cdl_num] );

      // end cell
      result.append("</td>");
      IDINL;

      // end row
      if ( (cdl_num%columns_cnt) == (columns_cnt-1) ) {
        result.append("</tr>");
        IDINL;
      }

      cdl_num++;
    }

    // end table
    result.append("</table>");
  }

  // ----------------------------------------------------------------- //
  //                            latex table
  // ----------------------------------------------------------------- //
  if ( type.compare("latex")==0 ) {

    // begin table
    IDINL;
    result.append("\\begin{table}[h]");
    IDINL;

    // SKIPPING: table_class, local formatting required here.

    // table caption
    if( table_caption.length() ) {
      result.append("\\caption{" + table_caption + "}" );
      IDINL;
    }

    // table id
    if ( id.length() ) {
      result.append("\\label{" + id + "}");
      IDINL;
    }

    result.append("\\begin{center}");
    IDINL;

    result.append("\\begin{tabular}{");
    for( size_t i=0; i<columns_cnt; ++i ) result.append("c");
    result.append("}");
    IDINL;

    // column headings
    if( column_headings.length() ) {
      result.append("\\hline ");
      IDINL;
      for( size_t i=0; i<columns_cnt; ++i ) {
        result.append( chl_v[i] );
        if ( i < (columns_cnt-1) ) result.append( "&" );
        else                       result.append( "\\\\" );
        IDINL;
      }
      result.append("\\hline");
      result.append("\\\\[2pt]");
      IDINL;
    }

    // iterate over cells
    int cdl_num = 0;
    for ( vector<string>::const_iterator it=cdl_v.begin(); it!=cdl_v.end(); ++it )
    {
      const string file = *it;

      // check new row
      if ( (cdl_num%columns_cnt) == 0 ) {
        // image captions
        if( cell_captions.length() ) {
          for( size_t i=0; i<columns_cnt; ++i ) {
            if( (cdl_num + i) < cdl_v.size() ) result.append( ccl_v[cdl_num + i] );
            else                               result.append( "~" );

            if ( i < (columns_cnt-1) )         result.append( "&" );
            else                               result.append( "\\\\" );
            IDINL;
          }
        }
        // begin row
      }

      // begin cell

      // begin cell image
      bool found = false;
      if ( cell_urls.length() ) result.append( "\\href{"
          + file_rl( cul_v[cdl_num], get_latex_output(), found )
          + "}{" );

      result.append("\\includegraphics");

      // assemble attributes
      string attr;
      if ( image_width.length() ) {
        if ( attr.length() )       { attr.append(","); }
                                     attr.append("width=" + image_width); }
      if ( image_height.length() ) {
        if ( attr.length() )       { attr.append(","); }
                                     attr.append("height=" + image_height); }

      if ( attr.length() )           result.append( "[" + attr + "]" );

      result.append( "{" + file_rl( file, get_latex_output(), found, false ) + "}" );

      if ( cell_urls.length() ) result.append( "}");

      // end cell image

      // end cell

      // check end row
      if ( (cdl_num%columns_cnt) == (columns_cnt-1) ) {
        result.append("\\\\");
        IDINL;

        if( cell_titles.length() ) {
          for( size_t i=0; i<columns_cnt; ++i ) {
            int os=1 - columns_cnt;
            if( (cdl_num + i + os) < cdl_v.size() ) result.append( ctl_v[cdl_num + i + os] );
            else                                    result.append( "~" );

            if ( i < (columns_cnt-1) )              result.append( "&" );
            else                                    result.append( "\\\\[2pt]" );

            IDINL;
          }
        }
      } else {
        result.append("&");
        IDINL;
      }

      cdl_num++;
    }

    // final partial row
    if ( (cdl_num%columns_cnt) != 0 ) {
      // fill any remaining cells with "~" to complete the partial row
      for( size_t i=( (cdl_num%columns_cnt) ) ; i<(columns_cnt-1); ++i ) {
        result.append("~&");
        IDINL;
      }
      // end
      result.append("~\\\\");
      IDINL;

      // partial row titles
      if( cell_titles.length() ) {
        for( size_t i=0; i<columns_cnt; ++i ) {
          int os=0 - cdl_num%columns_cnt;
          if( (cdl_num + i + os) < cdl_v.size() ) result.append( ctl_v[cdl_num + i + os] );
          else                                    result.append( "~" );

          if ( i < (columns_cnt-1) )              result.append( "&" );
          else                                    result.append( "\\\\" );

          IDINL;
        }
      }
    }

    // end table
    result.append("\\end{tabular}"); IDINL;
    result.append("\\end{center}"); IDINL;
    result.append("\\end{table}");
  }

  return( result );
}

/***************************************************************************//**

  \details

    javascript viewers: png, stl, svg, movie...

    For more information on how to specify and use function arguments
    see \ref openscad_dif_sm_a.

*******************************************************************************/
string
ODIF::ODIF_Scanner::bif_viewer(void)
{
  string result;

  result = amu_error_msg("unimplemented.");

  return( result );
}

/***************************************************************************//**

  \details

    Run \em make on an embedded MFScript using a specified target and
    capture the result.

    The scope identifier is initially the default \em root scope
    (specified by the program option set on the command line or in a
    configuration file). Each argument is then processes to modify the
    scope identifier according to the description in the following table.
    All positional arguments are treated as \p append options.

     options        | sc  | default      |  description
    :--------------:|:---:|:------------:|:------------------------------------
      set           | si  |              | set the scope identifier to argument
      append        | a   |              | append argument to scope identifier
      prepend       | p   |              | prepend argument to scope identifier
      extension     | e   |              | limit targets by extension
      target_prefix | tp  | echo_targets | make target prefix

    Command flags and result filtering.

     flags     | sc  | default | description
    :---------:|:---:|:-------:|:-----------------------------------------
      stderr   | s   | false   | capture standard error output as well
      rmnl     | r   | true    | remove line-feeds / carriage returns
      pstarget | pst | false   | target is from parent source file

    A makefile build script can generate targets from either a scope
    embedded script or the the parent source file. The flag \p pstarget
    is used to distinguish between these origins. Setting \p ++pstarget
    will use targets generated by the parent source file.

  \note Under normal operation, the output text from the makefile
        target should be contained within a single line so as to not
        change the line count of the source file.

    For more information on how to specify and use function arguments
    see \ref openscad_dif_sm_a.

*******************************************************************************/
string
ODIF::ODIF_Scanner::bif_make(void)
{
  // options declaration: vana & vans.
  // !!DO NOT REORDER WITHOUT UPDATING POSITIONAL DEPENDENCIES BELOW!!
  string vana[] =
  {
  "set",              "si",
  "append",           "a",
  "prepend",          "p",
  "extension",        "e",
  "target_prefix",    "tp",
  "stderr",           "s",
  "rmnl",             "r",
  "pstarget",         "pst"
  };
  set<string> vans(vana, vana + sizeof(vana)/sizeof(string));

  size_t ap=16;

  // generate options help string.
  string help = "options: [";
  for(size_t it=0; it < ap; it+=2) {
    if (it) help.append( ", " );
    help.append( vana[it] + " (" + vana[it+1] + ")" );
  }
  help.append( "]" );

  //
  // assemble scope identifiers
  //
  string makefile_stem = get_rootscope();
  string make_target = get_rootscope();

  string target_prefix = "echo_targets";
  string mf_scopejoiner = "_";
  string target_ext;

  // flag defaults
  bool flag_stde = false;
  bool flag_rmnl = true;
  bool flag_pstarget = false;

  // iterate over the arguments, skipping function name (position zero)
  for ( vector<func_args::arg_term>::iterator it=fx_argv.argv.begin()+1;
                                              it!=fx_argv.argv.end();
                                              ++it )
  {
    string n = it->name;
    string v = it->value;

    if ( it->positional )
    { // append
      makefile_stem = makefile_stem + get_scopejoiner() + v;
      make_target = make_target + mf_scopejoiner + v;
    }
    else
    {
      if      (!(n.compare(vana[0])&&n.compare(vana[1])))
      { // set
        makefile_stem = v;
        make_target = v;
      }
      else if (!(n.compare(vana[2])&&n.compare(vana[3])))
      { // append
        makefile_stem = makefile_stem + get_scopejoiner() + v;
        make_target = make_target + mf_scopejoiner + v;
      }
      else if (!(n.compare(vana[4])&&n.compare(vana[5])))
      { // prepend
        makefile_stem = v + get_scopejoiner() + makefile_stem;
        make_target = v + mf_scopejoiner + make_target;
      }
      else if (!(n.compare(vana[6])&&n.compare(vana[7])))
      { // extension
        target_ext = v;
      }
      else if (!(n.compare(vana[8])&&n.compare(vana[9])))
      { // target_prefix
        target_prefix = v;
      }
      else if (!(n.compare(vana[10])&&n.compare(vana[11])))
      { // stderr
        flag_stde=( atoi( v.c_str() ) > 0 );
      }
      else if (!(n.compare(vana[12])&&n.compare(vana[13])))
      { // rmnl
        flag_rmnl=( atoi( v.c_str() ) > 0 );
      }
      else if (!(n.compare(vana[14])&&n.compare(vana[15])))
      { // pstarget
        flag_pstarget=( atoi( v.c_str() ) > 0 );
      }
      else
      { // invalid
        return( amu_error_msg(n + "=" + v + " invalid option. " + help) );
      }
    }
  }

  // parent source file target
  if ( flag_pstarget )
    make_target = get_rootscope();

  // target extension limiter
  if ( target_ext.length() )
    make_target = make_target + mf_scopejoiner + target_ext;

  //
  // assemble system command
  //
  string scmd;
  string opts = " --no-print-directory";

  // identify path prefix to makefile
  if ( get_prefix_scripts() )
    opts += " --directory=" + get_output_prefix();
  else if ( get_config_prefix().compare(".") && get_config_prefix().length() )
    opts += " --directory=" + get_config_prefix();

  scmd = get_make_path() + opts
       + " --makefile=" + makefile_stem + get_makefile_ext()
       + " " + target_prefix + mf_scopejoiner + make_target;

  // issue system command
  string result;
  bool good=false;

  filter_debug( scmd );
  UTIL::sys_command( scmd, result, good, flag_stde, flag_rmnl );

  if ( good )
  {
    return( result );
  }
  else
  {
    return( amu_error_msg( result ) );
  }
}

/***************************************************************************//**
  \details

    Copy the list of files to the output directory for the specified
    documentation types.

     options    | sc  | default | description
    :----------:|:---:|:-------:|:-----------------------------
      files     | f   |         | list of files
      types     | t   |         | html, latex, docbook, or rtf

    The tokenizer character that separates list members are summarized in the
    following table.

     type     | any of
    :--------:|:------------:
     files    | [,[:space:]]
     types    | [,[:space:]]

    For more information on how to specify and use function arguments
    see \ref openscad_dif_sm_a.

*******************************************************************************/
string
ODIF::ODIF_Scanner::bif_copy(void)
{
  // options declaration: vana & vans.
  // !!DO NOT REORDER WITHOUT UPDATING POSITIONAL DEPENDENCIES BELOW!!
  string vana[] =
  {
  "files",            "f",
  "types",            "t"
  };
  set<string> vans(vana, vana + sizeof(vana)/sizeof(string));

  // variables
  size_t ap=0;
  string files;  ap+=2;
  string types;  ap+=2;

  // generate options help string.
  string help = "options: [";
  for(size_t it=0; it < ap; it+=2) {
    if (it) help.append( ", " );
    help.append( vana[it] + " (" + vana[it+1] + ")" );
  }
  help.append( "]" );

  // iterate over the arguments, skipping function name (position zero)
  for ( vector<func_args::arg_term>::iterator it=fx_argv.argv.begin()+1;
                                              it!=fx_argv.argv.end();
                                              ++it )
  {
    string n = it->name;
    string v = it->value;

    if ( it->positional )
    { // invalid
      return( amu_error_msg(n + "=" + v + " invalid option. " + help) );
    }
    else
    {
      if      (!(n.compare(vana[0])&&n.compare(vana[1])))
      { // files
        files = UTIL::unquote_trim( v );
      }
      else if (!(n.compare(vana[2])&&n.compare(vana[3])))
      { // types
        types = UTIL::unquote_trim( v );
      }
      else
      { // invalid
        return( amu_error_msg(n + "=" + v + " invalid option. " + help) );
      }
    }
  }

  //
  // validate arguments
  //
  typedef boost::tokenizer< boost::char_separator<char> > tokenizer;
  boost::char_separator<char> fsep(", ");

  tokenizer f_tok( files, fsep );
  tokenizer t_tok( types, fsep );

  vector<string> outpath;

  for ( tokenizer::iterator tit=t_tok.begin(); tit!=t_tok.end(); ++tit )
  {
    if      ( !tit->compare("html") )
    {
      outpath.push_back( get_html_output() );
    }
    else if ( !tit->compare("latex") )
    {
      outpath.push_back( get_latex_output() );
    }
    else if ( !tit->compare("docbook") )
    {
      outpath.push_back( get_docbook_output() );
    }
    else if ( !tit->compare("rtf") )
    {
      outpath.push_back( get_rtf_output() );
    }
    else
    {
      return( amu_error_msg( *tit + " invalid type option. "
                                    "may be [html, latex, docbook, or rtf].") );
    }
  }

  filter_debug(fx_name + " begin", true, false, true);

  filter_debug("files=[" + files + "]", false, false, true);
  filter_debug("types=[" + types + "]", false, false, true);

  string result;

  // iterate over each file and output path
  for ( tokenizer::iterator fit=f_tok.begin(); fit!=f_tok.end(); ++fit )
  {
    for ( vector<string>::iterator pit=outpath.begin(); pit!=outpath.end(); ++pit )
    {
      string file( *fit );
      string path( *pit );

      bool found = false;
      string rl = file_rl( file, path, found );

      if ( found == false )
        result.append(rl + " ");

      filter_debug("copy " + file + " to " + path + " : " +
                   (found?string("ok"):string("not found")),
                   false, false, true);
    }
  }

  filter_debug(fx_name + " end", false, true, true);

  if ( result.length() )
  {
    return ( amu_error_msg("not found: " + result) );
  }
  else
  {
    return( result );
  }
}

/***************************************************************************//**
  \details

    Search for files in the include-paths. If found, return the located
    file paths.

    The options and flags (and their short codes) are summarized in the
    following tables.

     options    | sc  | default | description
    :----------:|:---:|:-------:|:-----------------------------
      files     | f   |         | list of files
      nfl       | n   | 1       | file not-found limit (0 = unlimited)

    Command flags.

     flags     | sc  | default | description
    :---------:|:---:|:-------:|:-----------------------------------------
      rmnl     | r   | true    | remove line-feeds / carriage returns
      skip     | s   | false   | skip files that are not found

    The tokenizer character that separates list members are summarized
    in the following table.

     type     | any of
    :--------:|:------------:
     files    | [,[:space:]]

  \note List of files should be enclosed in quotations (single or
        double).

    For more information on how to specify and use function arguments
    see \ref openscad_dif_sm_a.

*******************************************************************************/
string
ODIF::ODIF_Scanner::bif_find(void)
{
  // options declaration: vana & vans.
  // !!DO NOT REORDER WITHOUT UPDATING POSITIONAL DEPENDENCIES BELOW!!
  string vana[] =
  {
  "files",    "f",
  "nfl",      "n",
  "rmnl",     "r",
  "skip",     "s"
  };
  set<string> vans(vana, vana + sizeof(vana)/sizeof(string));

  // variables
  size_t ap=0;
  string files;           ap+=2;
  int nfl = 1;            ap+=2;

  // flags
  bool flag_rmnl = true;  ap+=2;
  bool flag_skip = false; ap+=2;

  // generate options help string.
  string help = "options: [";
  for(size_t it=0; it < ap; it+=2) {
    if (it) help.append( ", " );
    help.append( vana[it] + " (" + vana[it+1] + ")" );
  }
  help.append( "]" );

  // iterate over the arguments, skipping function name (position zero)
  for ( vector<func_args::arg_term>::iterator it=fx_argv.argv.begin()+1;
                                              it!=fx_argv.argv.end();
                                              ++it )
  {
    string n = it->name;
    string v = it->value;

    if ( it->positional )
    { // invalid
      return( amu_error_msg(n + "=" + v + " invalid option. " + help) );
    }
    else
    {
      if      (!(n.compare(vana[0])&&n.compare(vana[1])))
      { // files
        files = UTIL::unquote_trim( v );
      }
      else if (!(n.compare(vana[2])&&n.compare(vana[3])))
      { // abort
        nfl = atoi( v.c_str() );
      }
      else if (!(n.compare(vana[4])&&n.compare(vana[5])))
      { // rmnl
        flag_rmnl=( atoi( v.c_str() ) > 0 );
      }
      else if (!(n.compare(vana[6])&&n.compare(vana[7])))
      { // skip
        flag_skip=( atoi( v.c_str() ) > 0 );
      }
      else
      { // invalid
        return( amu_error_msg(n + "=" + v + " invalid option. " + help) );
      }
    }
  }

  // remove line-feeds / carriage returns
  if ( flag_rmnl )
    files = UTIL::replace_chars(files, "\n\r", ' ');

  typedef boost::tokenizer< boost::char_separator<char> > tokenizer;
  boost::char_separator<char> fsep(", ");

  tokenizer f_tok( files, fsep );

  filter_debug(fx_name + " begin", true, false, true);

  filter_debug("files=[" + files + "]", false, false, true);

  string result;
  int nfc = 0;

  // iterate over each file
  for ( tokenizer::iterator fit=f_tok.begin(); fit!=f_tok.end(); ++fit )
  {
    string file( *fit );

    bool found = false;
    string rl = file_rl( file, NO_FORMAT_OUTPUT, found );

    if ( found == false )
      nfc++;

    // add unless both not found and flag_skip is true
    if ( ! ((found == false) && (flag_skip == true)) )
      result.append(rl + " ");

    filter_debug("find " + file + " : " +
                 (found?(string("found --> ") + rl):string("not found")),
                 false, false, true);
  }

  filter_debug(fx_name + " end", false, true, true);

  // skip test when nfl <= 0
  if ( (nfc > nfl) && (nfl > 0) )
    return
    ( amu_error_msg
      (
        UTIL::to_string(nfc) + "(>" +
        UTIL::to_string(nfl) + ") file(s) not found: " + result
      )
    );
  else
    return( result );
}

/***************************************************************************//**
  \details

    Return information about embedded scopes.

    The options and flags (and their short codes) are summarized in the
    following tables.

    Options that require arguments.

     options   | sc  | default | description
    :---------:|:---:|:-------:|:-----------------------------
      index    | i   |         | return scope at specified index

    Flags that produce output.

     flags     | sc  | default | description
    :---------:|:---:|:-------:|:-----------------------------------------
      count    | c   | false   | return scope count
      list     | l   | false   | return scope list
      join     | j   | false   | return scope joiner
      root     | r   | false   | return root scope

    Flags that control the produced output.

     flags     | sc  | default | description
    :---------:|:---:|:-------:|:-----------------------------------------
      make     | m   | true    | only consider scopes with makefiles
      sort     | s   | false   | sort scope list
      unique   | u   | true    | only consider unique scope names
      verbose  | v   | false   | use verbose output

    The \p make flag requires that the filter be run with the search
    command line option.

    For more information on how to specify and use function arguments
    see \ref openscad_dif_sm_a.

*******************************************************************************/
string
ODIF::ODIF_Scanner::bif_scope(void)
{
  using namespace UTIL;

  // options declaration: vana & vans.
  // !!DO NOT REORDER WITHOUT UPDATING POSITIONAL DEPENDENCIES BELOW!!
  string vana[] =
  {
  "make",     "m",
  "sort",     "s",
  "unique",   "u",
  "verbose",  "v",

  "index",    "i",
  "count",    "c",
  "list",     "l",
  "join",     "j",
  "root",     "r"
  };
  set<string> vans(vana, vana + sizeof(vana)/sizeof(string));

  // assign local variable values: positions must match declaration above.
  size_t ap=18;
  bool make     = ( atoi( unquote_trim(fx_argv.arg_firstof("1",vana[0],vana[1])).c_str() ) > 0 );
  bool sort     = ( atoi( unquote_trim(fx_argv.arg_firstof("0",vana[2],vana[3])).c_str() ) > 0 );
  bool unique   = ( atoi( unquote_trim(fx_argv.arg_firstof("1",vana[4],vana[5])).c_str() ) > 0 );
  bool verbose  = ( atoi( unquote_trim(fx_argv.arg_firstof("0",vana[6],vana[7])).c_str() ) > 0 );

  // generate options help string.
  string help = "options: [";
  for(size_t it=0; it < ap; it+=2) {
    if (it) help.append( ", " );
    help.append( vana[it] + " (" + vana[it+1] + ")" );
  }
  help.append( "]" );

  string result;
  std::vector<std::string> sid_copy;

  // make: assign copy of scope identifiers
  if ( make )
    sid_copy = get_scope_id_mf();
  else
    sid_copy = get_scope_id();

  // sort scope identifiers
  if ( sort )
  {
    std::sort(sid_copy.begin(), sid_copy.end());
  }

  // unique: limit scope identifiers to those that are unique
  if ( unique )
  {
    std::vector<std::string> sid_temp;

    // add unique elements from copy in ordered
    for ( vector<std::string>::iterator it=sid_copy.begin();
                                        it!=sid_copy.end();
                                        ++it )
    {
      // compare against unique list
      bool found = false;
      for ( vector<std::string>::iterator uit=sid_temp.begin();
                                          uit!=sid_temp.end() && !found;
                                          ++uit )
      {
        found = ( *it == *uit );
      }

      // add if not found
      if ( !found )
        sid_temp.push_back( *it );
    }

    sid_copy = sid_temp;
  }

  // iterate over the arguments, skipping function name (position zero)
  for ( vector<func_args::arg_term>::iterator it=fx_argv.argv.begin()+1;
                                              it!=fx_argv.argv.end();
                                              ++it )
  {
    string n = it->name;
    string v = it->value;
    bool flag = ( atoi( v.c_str() ) > 0 );   // assign flag value

    if ( it->positional )
    { // invalid
      return( amu_error_msg(n + "=" + v + " invalid option. " + help) );
    }
    else
    {
      if      (
                !(n.compare(vana[0])&&n.compare(vana[1])) ||  // make
                !(n.compare(vana[2])&&n.compare(vana[3])) ||  // sort
                !(n.compare(vana[4])&&n.compare(vana[5])) ||  // unique
                !(n.compare(vana[6])&&n.compare(vana[7]))     // verbose
              )
      {
        // do nothing, control flags values set above.
      }
      else if (!(n.compare(vana[8])&&n.compare(vana[9])) && flag)
      { // index
        size_t index = atoi( v.c_str() );

        if ( index < 1 )                index = 1;
        if ( index > sid_copy.size() )  index = sid_copy.size();

        if ( result.size() ) result.append( " " );
        if ( verbose ) result.append( "index[" + to_string(index) + "] = " );

        result.append( sid_copy[ index - 1 ] );
      }
      else if (!(n.compare(vana[10])&&n.compare(vana[11])) && flag)
      { // count
        if ( result.size() ) result.append( " " );
        if ( verbose ) result.append( "count = " );

        result.append( to_string( sid_copy.size() ) );
      }
      else if (!(n.compare(vana[12])&&n.compare(vana[13])) && flag)
      { // list
        if ( verbose )
        {
          if ( result.size() ) result.append( " " );
          result.append( "list =" );
        }

        for ( vector<string>::iterator vit=sid_copy.begin();
                                       vit!=sid_copy.end();
                                       ++vit )
        {
          if ( result.size() ) result.append( " " );
          result.append( *vit );
        }
      }
      else if (!(n.compare(vana[14])&&n.compare(vana[15])) && flag)
      { // join
        if ( result.size() ) result.append( " " );
        if ( verbose ) result.append( "join = " );

        result.append( get_scopejoiner() );
      }
      else if (!(n.compare(vana[16])&&n.compare(vana[17])) && flag)
      { // root
        if ( result.size() ) result.append( " " );
        if ( verbose ) result.append( "root = " );

        result.append( get_rootscope() );
      }
      else
      { // invalid
        return( amu_error_msg(n + "=" + v + " invalid option. " + help) );
      }
    }
  }

  return ( result );
}

/***************************************************************************//**
  \details

    Return information about source input file.

    The options and flags (and their short codes) are summarized in the
    following tables.

    Flags that produce output.

     flags     | sc  | default | description
    :---------:|:---:|:-------:|:-----------------------------------------
      file     | f   | false   | return source filename
      path     | p   | false   | return source pathname
      base     | b   | false   | return source basename
      stem     | s   | false   | return source stemname
      ext      | e   | false   | return source file extension

    Flags that control the produced output.

     flags     | sc  | default | description
    :---------:|:---:|:-------:|:-----------------------------------------
      absolute | a   | false   | return absolute path
      verbose  | v   | false   | use verbose output

    For more information on how to specify and use function arguments
    see \ref openscad_dif_sm_a.

*******************************************************************************/
string
ODIF::ODIF_Scanner::bif_source(void)
{
  using namespace UTIL;

  // options declaration: vana & vans.
  // !!DO NOT REORDER WITHOUT UPDATING POSITIONAL DEPENDENCIES BELOW!!
  string vana[] =
  {
  "absolute", "a",
  "verbose",  "v",

  "file",     "f",
  "path",     "p",
  "base",     "b",
  "stem",     "s",
  "ext",      "e"
  };
  set<string> vans(vana, vana + sizeof(vana)/sizeof(string));

  // assign local variable values: positions must match declaration above.
  size_t ap=14;
  bool absolute = ( atoi( unquote_trim(fx_argv.arg_firstof("0",vana[0],vana[1])).c_str() ) > 0 );
  bool verbose  = ( atoi( unquote_trim(fx_argv.arg_firstof("0",vana[2],vana[3])).c_str() ) > 0 );

  // generate options help string.
  string help = "options: [";
  for(size_t it=0; it < ap; it+=2) {
    if (it) help.append( ", " );
    help.append( vana[it] + " (" + vana[it+1] + ")" );
  }
  help.append( "]" );

  string result;

  bfs::path input_path;
  string path_type;

  if ( absolute )
  { // get absolute path
    path_type = "absolute";

    input_path = input_name;
  }
  else
  { // get relative path
    path_type = "relative";

    input_path = input_name;
    input_path = UTIL::get_relative_path(input_path, bfs::current_path());
  }

  // iterate over the arguments, skipping function name (position zero)
  for ( vector<func_args::arg_term>::iterator it=fx_argv.argv.begin()+1;
                                              it!=fx_argv.argv.end();
                                              ++it )
  {
    string n = it->name;
    string v = it->value;
    bool flag = ( atoi( v.c_str() ) > 0 );   // assign flag value

    if ( it->positional )
    { // invalid
      return( amu_error_msg(n + "=" + v + " invalid option. " + help) );
    }
    else
    {
      if      (
                !(n.compare(vana[0])&&n.compare(vana[1])) ||  // absolute
                !(n.compare(vana[2])&&n.compare(vana[3]))     // verbose
              )
      {
        // do nothing, control flags values set above.
      }
      else if (!(n.compare(vana[4])&&n.compare(vana[5])) && flag)
      { // file
        if ( result.size() ) result.append( " " );
        if ( verbose ) result.append( path_type + " filename = " );

        result.append( input_path.string() );
      }
      else if (!(n.compare(vana[6])&&n.compare(vana[7])) && flag)
      { // path
        if ( result.size() ) result.append( " " );
        if ( verbose ) result.append( path_type + " pathname = " );

        result.append( input_path.parent_path().string() );
      }
      else if (!(n.compare(vana[8])&&n.compare(vana[9])) && flag)
      { // base
        if ( result.size() ) result.append( " " );
        if ( verbose ) result.append( "basename = " );

        result.append( input_path.filename().string() );
      }
      else if (!(n.compare(vana[10])&&n.compare(vana[11])) && flag)
      { // stem
        if ( result.size() ) result.append( " " );
        if ( verbose ) result.append( "stemname = " );

        result.append( input_path.stem().string() );
      }
      else if (!(n.compare(vana[12])&&n.compare(vana[13])) && flag)
      { // ext
        if ( result.size() ) result.append( " " );
        if ( verbose ) result.append( "extension = " );

        result.append( input_path.extension().string() );
      }
      else
      { // invalid
        return( amu_error_msg(n + "=" + v + " invalid option. " + help) );
      }
    }
  }

  return ( result );
}

/***************************************************************************//**
  \details

    Return information about source path.

    The options and flags (and their short codes) are summarized in the
    following tables.

    Options that require arguments.

     options      | sc  | default | description
    :------------:|:---:|:-------:|:-----------------------------------------
      head        | h   |         | path name from head at location
      tail        | t   |         | path name from tail at location

    Flags that produce output.

     flags        | sc  | default | description
    :------------:|:---:|:-------:|:-----------------------------------------
      full        | f   | false   | full path name to input from root
      path        | a   | false   | full path name to input after root
      full_parent | fp  | false   | full parent path name to input from root
      path_parent | ap  | false   | full parent path name to input after root

    Flags that produce output.

     flags        | sc  | default | description
    :------------:|:---:|:-------:|:-----------------------------------------
      root        | r   | false   | root path name
      stem        | s   | false   | input stem name
      dir         | d   | false   | input directory name
      parent      | p   | false   | input parent directory name

    For more information on how to specify and use function arguments
    see \ref openscad_dif_sm_a.

*******************************************************************************/
string
ODIF::ODIF_Scanner::bif_pathid(void)
{
  using namespace UTIL;

  // options declaration: vana & vans.
  // !!DO NOT REORDER WITHOUT UPDATING POSITIONAL DEPENDENCIES BELOW!!
  string vana[] =
  {
  "head",         "h",
  "tail",         "t",

  "full",         "f",
  "path",         "a",
  "full_parent",  "fp",
  "path_parent",  "ap",

  "root",         "r",
  "stem",         "s",
  "dir",          "d",
  "parent",       "p"
  };
  set<string> vans(vana, vana + sizeof(vana)/sizeof(string));

  // assign local variable values: positions must match declaration above.
  size_t ap=20;

  // generate options help string.
  string help = "options: [";
  for(size_t it=0; it < ap; it+=2) {
    if (it) help.append( ", " );
    help.append( vana[it] + " (" + vana[it+1] + ")" );
  }
  help.append( "]" );

  string result;

  bfs::path input_path = input_name;
  bfs::path parent_path;

  string path_joiner = "_";

  // get relative parent path.
  input_path = UTIL::get_relative_path(input_path, bfs::current_path());
  parent_path = input_path.parent_path();

  //
  // create vector of parent path levels
  //
  vector<string> input_path_vec;

  // start with 'root'
  input_path_vec.push_back("root");

  // add each directory of parent_path from left to right
  for (bfs::path::const_iterator pi=parent_path.begin();
                                 pi!=parent_path.end();
                                 ++pi)
  {
    input_path_vec.push_back( pi->string() );
  }

  // iterate over the arguments, skipping function name (position zero)
  for ( vector<func_args::arg_term>::iterator it=fx_argv.argv.begin()+1;
                                              it!=fx_argv.argv.end();
                                              ++it )
  {
    string n = it->name;
    string v = it->value;

    bool flag = ( atoi( v.c_str() ) > 0 );    // assign flag value
    bool limited = false;
    size_t index = atoi( v.c_str() );         // assign value as integer

    // limit index
    if ( index > (input_path_vec.size()-1) )
    {
      index = input_path_vec.size()-1;
      limited = true;
    }

    if ( it->positional )
    { // invalid
      return( amu_error_msg(n + "=" + v + " invalid option. " + help) );
    }
    else
    {
      //
      // [ option with integer argument ]
      //

      if      (!(n.compare(vana[0])&&n.compare(vana[1])))
      { // head
        if ( result.size() ) result.append( path_joiner );
        if ( limited ) result.append( "limited" + path_joiner );
        result.append( input_path_vec[ index ] );
      }
      else if (!(n.compare(vana[2])&&n.compare(vana[3])))
      { // tail
        if ( result.size() ) result.append( path_joiner );
        result.append( input_path_vec[ input_path_vec.size() - 1 - index ] );
        if ( limited ) result.append( path_joiner + "limited" );
      }

      //
      // [ flags ]
      //

      else if (!(n.compare(vana[4])&&n.compare(vana[5])) && flag)
      { // full
        for( vector<string>::iterator vit=input_path_vec.begin();
                                      vit!=input_path_vec.end();
                                      ++vit)
        {
          if ( result.size() ) result.append( path_joiner );
          result.append( *vit );
        }
      }
      else if (!(n.compare(vana[6])&&n.compare(vana[7])) && flag)
      { // path
        if ( input_path_vec.size() > 1 )
        {
          for( vector<string>::iterator vit=input_path_vec.begin()+1;
                                        vit!=input_path_vec.end();
                                        ++vit)
          {
            if ( result.size() ) result.append( path_joiner );
            result.append( *vit );
          }
        }
      }
      else if (!(n.compare(vana[8])&&n.compare(vana[9])) && flag)
      { // full_parent
        if ( input_path_vec.size() > 1 )
        {
          for( vector<string>::iterator vit=input_path_vec.begin();
                                        vit!=input_path_vec.end()-1;
                                        ++vit)
          {
            if ( result.size() ) result.append( path_joiner );
            result.append( *vit );
          }
        }
        else
        {
          result.append( "none" );
        }
      }
      else if (!(n.compare(vana[10])&&n.compare(vana[11])) && flag)
      { // path_parent
        if ( input_path_vec.size() > 2 )
        {
          for( vector<string>::iterator vit=input_path_vec.begin()+1;
                                        vit!=input_path_vec.end()-1;
                                        ++vit)
          {
            if ( result.size() ) result.append( path_joiner );
            result.append( *vit );
          }
        }
      }

      //
      // [ flags ]
      //

      else if (!(n.compare(vana[12])&&n.compare(vana[13])) && flag)
      { // root
        if ( result.size() ) result.append( path_joiner );
        result.append( input_path_vec[ 0 ] );
      }
      else if (!(n.compare(vana[14])&&n.compare(vana[15])) && flag)
      { // stem
        if ( result.size() ) result.append( path_joiner );
        result.append( input_path.stem().string() );
      }
      else if (!(n.compare(vana[16])&&n.compare(vana[17])) && flag)
      { // dir
        if ( result.size() ) result.append( path_joiner );
        result.append( input_path_vec[ input_path_vec.size() - 1 ] );
      }
      else if (!(n.compare(vana[18])&&n.compare(vana[19])) && flag)
      { // parent or 'none'
        if ( result.size() ) result.append( path_joiner );
        if ( input_path_vec.size() > 1 )
          result.append( input_path_vec[ input_path_vec.size() - 2 ] );
        else
          result.append( "none" );
      }
      else
      { // invalid
        return( amu_error_msg(n + "=" + v + " invalid option. " + help) );
      }
    }
  }

  return ( result );
}

/***************************************************************************//**
  \details

    Perform filename operations on a list of files.

    The options and flags (and their short codes) are summarized in the
    following tables.

    Options that require arguments.

     options      | sc  | default       | description
    :------------:|:---:|:-------------:|:-----------------------------------------
      files       | f   |               | list of files
      tokenizer   | t   | [,[:space:]]  | tokenizer to separate files in list
      separator   | r   | [[:space:]]   | file separator for resulting list

    Flags that produce output.

     flags     | sc  | default | description
    :---------:|:---:|:-------:|:-----------------------------------------
      file     | n   | false   | return filename for each file
      path     | p   | false   | return pathname for each file
      base     | b   | false   | return basename for each file
      stem     | s   | false   | return stemname for each file
      ext      | e   | false   | return extension for each file

    For more information on how to specify and use function arguments
    see \ref openscad_dif_sm_a.

*******************************************************************************/
string
ODIF::ODIF_Scanner::bif_filename(void)
{
  using namespace UTIL;

  // options declaration: vana & vans.
  // !!DO NOT REORDER WITHOUT UPDATING POSITIONAL DEPENDENCIES BELOW!!
  string vana[] =
  {
  "files",      "f",

  "tokenizer",  "t",
  "separator",  "r",

  "file",       "n",
  "path",       "p",
  "base",       "b",
  "stem",       "s",
  "ext",        "e"
  };
  set<string> vans(vana, vana + sizeof(vana)/sizeof(string));

  // generate options help string.
  size_t ap=16;
  string help = "options: [";
  for(size_t it=0; it < ap; it+=2) {
    if (it) help.append( ", " );
    help.append( vana[it] + " (" + vana[it+1] + ")" );
  }
  help.append( "]" );

  //
  // assemble result
  //
  string result;

  string tokl = ", ";   // assign default token list
  string fsep = " ";    // assign default output file separator

  vector<string> fl_v;

  // iterate over the arguments, skipping function name (position zero)
  for ( vector<func_args::arg_term>::iterator it=fx_argv.argv.begin()+1;
                                              it!=fx_argv.argv.end();
                                              ++it )
  {
    string n = it->name;
    string v = it->value;
    bool flag = ( atoi( v.c_str() ) > 0 );   // assign flag value

    if ( it->positional )
    { // invalid
      return( amu_error_msg(n + "=" + v + " invalid option. " + help) );
    }
    else
    {
      if (!(n.compare(vana[0])&&n.compare(vana[1])))
      { // file list
        string fl_s = unquote( v );

        typedef boost::tokenizer< boost::char_separator<char> > tokenizer;
        boost::char_separator<char> fsep( tokl.c_str() );
        tokenizer fl_tok( fl_s, fsep );

        fl_v.clear();
        for ( tokenizer::iterator fit=fl_tok.begin(); fit!=fl_tok.end(); ++fit )
          fl_v.push_back( boost::trim_copy( *fit ) );
      }

      else if (!(n.compare(vana[2])&&n.compare(vana[3])))
      { // tokenizer
        tokl = unquote( v );
      }
      else if (!(n.compare(vana[4])&&n.compare(vana[5])))
      { // separator
        fsep = unquote( v );
      }

      //
      // flags
      //
      else if (!(n.compare(vana[6])&&n.compare(vana[7])) && flag)
      { // file
        for ( vector<string>::const_iterator fit=fl_v.begin(); fit!=fl_v.end(); ++fit )
        {
          if ( result.size() ) result.append( fsep );
            result.append( bfs::path( *fit ).string() );
        }
      }
      else if (!(n.compare(vana[8])&&n.compare(vana[9])) && flag)
      { // path
        for ( vector<string>::const_iterator fit=fl_v.begin(); fit!=fl_v.end(); ++fit )
        {
          if ( result.size() ) result.append( fsep );
            result.append( bfs::path( *fit ).parent_path().string() );
        }
      }
      else if (!(n.compare(vana[10])&&n.compare(vana[11])) && flag)
      { // base
        for ( vector<string>::const_iterator fit=fl_v.begin(); fit!=fl_v.end(); ++fit )
        {
          if ( result.size() ) result.append( fsep );
          result.append( bfs::path( *fit ).filename().string() );
        }
      }
      else if (!(n.compare(vana[12])&&n.compare(vana[13])) && flag)
      { // stem
        for ( vector<string>::const_iterator fit=fl_v.begin(); fit!=fl_v.end(); ++fit )
        {
          if ( result.size() ) result.append( fsep );
          result.append( bfs::path( *fit ).stem().string() );
        }
      }
      else if (!(n.compare(vana[14])&&n.compare(vana[15])) && flag)
      { // ext
        for ( vector<string>::const_iterator fit=fl_v.begin(); fit!=fl_v.end(); ++fit )
        {
          if ( result.size() ) result.append( fsep );
          result.append( bfs::path( *fit ).extension().string() );
        }
      }

      else
      { // invalid
        return( amu_error_msg(n + "=" + v + " invalid option. " + help) );
      }
    }
  }

  return ( result );
}

/***************************************************************************//**
  \details

    Perform search and replace on text. Regular expression support is
    provided by the [boost] regex_replace() library function.

    The options and flags (and their short codes) are summarized in the
    following tables.

    Options that require arguments.

     options    | sc  | default | description
    :----------:|:---:|:-------:|:--------------------------
      text      | t   |         | text string to seach
      search    | s   | []      | search regular expression
      replace   | r   | []      | replacement format string

    Flags.

     flags      | sc  | default | description
    :----------:|:---:|:-------:|:--------------------------------
      global    | g   | true    | replace all occurances
      literal   | l   | false   | treat format string as literal
      perl      | p   | false   | recognize perl format sequences
      sed       | e   | false   | recognize sed format sequences

    For more information on how to specify and use function arguments
    see \ref openscad_dif_sm_a.

    [boost]: https://www.boost.org
*******************************************************************************/
string
ODIF::ODIF_Scanner::bif_replace(void)
{
  using namespace UTIL;

  // options declaration: vana & vans.
  // !!DO NOT REORDER WITHOUT UPDATING POSITIONAL DEPENDENCIES BELOW!!
  string vana[] =
  {
  "text",     "t",
  "search",   "s",
  "replace",  "r",

  "global",   "g",
  "literal",  "l",
  "perl",     "p",
  "sed",      "e"
  };
  set<string> vans(vana, vana + sizeof(vana)/sizeof(string));

  // assign local variable values: positions must match declaration above.
  size_t ap=0;
  string text     = unquote(fx_argv.arg_firstof("",vana[ap],vana[ap+1])); ap+=2;
  string search   = unquote(fx_argv.arg_firstof("",vana[ap],vana[ap+1])); ap+=2;
  string replace  = unquote(fx_argv.arg_firstof("",vana[ap],vana[ap+1])); ap+=2;

  bool global     = ( atoi( unquote_trim(fx_argv.arg_firstof("1",vana[ap],vana[ap+1])).c_str() ) > 0 ); ap+=2;
  bool literal    = ( atoi( unquote_trim(fx_argv.arg_firstof("0",vana[ap],vana[ap+1])).c_str() ) > 0 ); ap+=2;
  bool perl       = ( atoi( unquote_trim(fx_argv.arg_firstof("0",vana[ap],vana[ap+1])).c_str() ) > 0 ); ap+=2;
  bool sed        = ( atoi( unquote_trim(fx_argv.arg_firstof("0",vana[ap],vana[ap+1])).c_str() ) > 0 ); ap+=2;

  // generate options help string.
  string help = "options: [";
  for(size_t it=0; it < ap; it+=2) {
    if (it) help.append( ", " );
    help.append( vana[it] + " (" + vana[it+1] + ")" );
  }
  help.append( "]" );

  // validate named arguments: (must be one of the declared options).
  vector<string> av = fx_argv.names_v(true, false);
  for ( vector<string>::iterator it=av.begin(); it!=av.end(); ++it )
    if ( vans.find( *it ) == vans.end() )
      return( amu_error_msg(*it + " invalid option. " + help) );

  //
  // general argument validation:
  //

  // enforce zero positional arguments (except arg0).
  if ( fx_argv.size(false, true) != 1 )
    return(amu_error_msg("requires zero positional argument. " + help));

  string result;

  using namespace boost::xpressive;
  sregex sre = sregex::compile( search );
  regex_constants::match_flag_type flags;

  flags = regex_constants::format_default;

  if ( !global )  flags = flags | regex_constants::format_first_only;
  if ( literal )  flags = flags | regex_constants::format_literal;
  if ( perl )     flags = flags | regex_constants::format_perl;
  if ( sed )      flags = flags | regex_constants::format_sed;

  result = regex_replace( text, sre, replace, flags );

  return ( result );
}


/*******************************************************************************
// eof
*******************************************************************************/
